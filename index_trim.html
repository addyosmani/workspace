
<h1>Find And Fix Mobile Web Rendering Issues</h1>


<p>The performance conversation is starting to change.</p>

<p>We're regularly comparing the web's performance to the performance of native and it's no longer just important to consider how quickly a site loads but also how well it runs. Whether it&rsquo;s on desktop or mobile, we want our web experience to be <strong>snappy</strong>, smooth and delightful. What this means is that even if the browser is busy <a href="http://taligarsiel.com/Projects/howbrowserswork1.htm#The_rendering_engine">rendering</a> the page (i.e drawing it) or loading in content, the user should still be able to scroll around and interact with it without any slow-down. No one likes seeing visual glitchyness.</p>

<p>Do you remember the last time you went out for a meal? I always feel like the greeting I get from waiters is "Welcome to our nearly empty restaraunt, sir! Please follow me to our worst table".  It's a lot like the types of web experiences we're going to try improving today. We've all been to pages where you try to scroll down, but no matter how hard you try, something just blocks you from getting where you want to. We can do better than that.</p>

<p>Many large sites, including <a href="https://twitter.com/igrigorik/status/300226402496704512">Facebook</a> and <a href="http://code.flickr.net/2013/06/04/adventures-in-jank-busting-parallax-performance-and-the-new-flickr-home-page/">Flickr</a> are starting to care about paint performance and frame rate more. They've found it can affect not only your user experience but also your user engagement. Measurement is the most important part of any performance profiling and this article focuses on how to do this within Chrome. Where possible, always check your sites and apps using the tooling in other browsers to double-check if your slowdown is browser-specific.</p>


<h2>The performance triangle</h2>

<p>Let's look at the three bits of performance we're interested in when we talk about mobile performance optimization: Network, Compute and Render.</p>

<p>Network</p>

<p>
60% of web traffic is images. That's a huge amount of data. Your users have to pay to download it if they're on a metered data plan each month (most users in the UK, as one example, are capped somewhere around the 1GB mark on mobile) and chances are your hosting is metered as well: you pay for users downloading files. As such you may want to look at the format in which you're serving your images. WebP currently offers huge file size savings when compared to the equivalent quality (that quality bit's important; you can always beat a codec by lowering your quality in another!) JPEG or PNG. If you run your own servers. you could do much worse than looking at mod_pagespeed, since that magically optimizes your site on the fly, minimizing and re-encoding assets.</p>

<p>Secondly you might want to take a look at the number of requests your site makes. Unless your user is on SPDY or HTTP 2.0 then every file will need to be requested separately, and every request will potentially have a large latency on it. It's worth remembering that bandwidth isn't latency, so even if you're on a 3G connection (or better), that doesn't necessarily correlate to lower latency!

Finally, bear in mind that a request will keep the radio active on a mobile device. The radio is the second most draining item after the screen, so really we want to get it shut off as soon as we can. Otherwise your users will complain that your site destroys battery life, and that's not a good complaint to have leveraged at you.</p>


<p>Compute</p>

<p>All our JavaScript runs inside an engine. In Chrome's case the engine is V8, and like other engines in top-tier browsers, it's incredibly fast. It's fast because it watches your code and swaps it out at the function level with an optimized equivalent code.</p>

<p>
The first thing you want to avoid is your code being deoptimized, which is where the old, slower code has to be resubstituted back in for the faster version. There are many reasons why this can happen, and they change (reminder: nothing stays the same) so the best thing you can do is to run a tool called d8, which is a standalone version of V8 which will tell you if your JavaScript got deoptimized. For more info check out Optimizing for V8 - Inlining, deoptimizations.</p>

<p>
Secondly, since you don't retain and release memory yourself in JavaScript, you're at the mercy of the garbage collector. Why? Because memory usage from all your declared objects would grow and grow. You never manually release their memory, so the garbage collector has to come and clean them up when they're not needed anymore. Unfortunately garbage collection (GC) is not free and blocks JavaScript execution while it tidies up. Chrome DevTools handily points out to you when GC has occurred, so you should take time to see if you're generating a lot of garbage and see if your code is being paused for its collection.</p>

<p>Render</p>

<p>Your DOM becoming pixels on the screen can be one of the most costly parts of your app's lifecycle. Crucially when additional painting needs to occur as part of interaction with your app can resulting the app slowing. UI interactions, scrolling, content injections all cause the page to visibly change, and those changes need to be painted to the screen.

Painting also encapsulates the decoding (you send a PNG, we need a bitmap in memory) and resizing (you send it at 1000px wide for a 300px wide element) of your app's images. Interestingly there's a cache available for these decoded images, but if you have a lot of images being decoded soon enough some images will need to be dropped from the cache.A quick study of the DevTools timeline will show you what's going on, so again it's worth checking those out.</p>


<h2>Jank - Visual Slowdown You Don't Want</h2>

<p>The human eye perceives a continuous stream of information. It does not naturally see motion as a series of frames.  In the worlds of animation, film and gaming, using a series of still frames to simulate motion create some interesting perceptual artifacts - especially if the frames are played back too slowly. This is because when you have a varying frame rate that isn't constant, our eyes perceive jerkiness and jitter, not smoothness in the motion, and what we see can appear to flicker.</p>

<p>For an optimal user experience, animations need to be silky, <a href="http://www.html5rocks.com/en/tutorials/speed/scrolling/">scrolling</a> must be buttery-smooth and your page needs to contain little to no jank - a term that means a <b>disruption</b> in consistent frame rate that manifests itself visually.</p>

<p>On the web, a low frame rate (and janky experience) means that individual frames being rendered by the browser can be made out by the human eye. Giving users a jank-free experience often comes down to offering an experience that can run at <strong>60fps</strong> on sites and web apps, not just games and animations. At 60fps, you have 16.66ms to complete absolutely everything in for Chrome to display a frame of your page - that's logic processing, painting, layout, image decoding, compositing..everything. Once you factor in mischellaneous browser processes, this number looks more like 8-10ms and blowing this budget can mean your users are more likely to see jank in their pages.</p>

<p>What's magical about the number 60? Well, we say 60fps as this matches the refresh rate of those of the devices we use today. Animations should match the refresh of the device they are being used on. Phones are usually 55-60hz. Laptops 58-60hz (although 50hz in low power mode) and most monitors are 50-62hz.</p>

<p>To hit 60fps, we sometimes need to go&nbsp;<strong>beyond </strong>JavaScript as the sole performance bottleneck for our pages and spend more time investigating paint and layout issues - styles might actually be the core cause of our sluggish performance.

<p>Some of the core causes of jank in sites and applications include:</p>

<ul>
	<li>Heavy paint times for your DOM elements</li>
	<li>Unnecessary image resizes (because you haven't pre-scaled to the size you need)</li>
	<li>Long image-decodes (e.g decoding PNG/JPEG)</li>
	<li>Unexpected layer invalidations</li>
	<li>Garbage collector runs</li>
	<li>Network requests (e.g processing an XHR)</li>
	<li>Heavy animation or data processing. </li>
	<li>Input handlers with a heavy amount of JavaScript. One common mistake is adding a lot of JavaScript to rearrange the page in an onscroll handler which impacts paint times.</li>
</ul>

<h2>requestAnimation Frame</h2>

<p>Many web developers use <code>setInterval</code> or <code>setTimeout</code> every 16 milliseconds to create animations. This is a problem for a variety of reasons (and we'll discuss more in a minute), but of particular concern are:</p>
<ul>
<li>Timer resolution from JavaScript is only on the order of several milliseconds</li>
<li>Different devices have different refresh rates</li>
</ul>
<p>Recall the frame timing problem mentioned above: you need a completed animation frame, finished with any JavaScript, DOM manipulation, layout, painting, etc, to be ready before the next screen refresh occurs. Low timer resolution can make it difficult to get animation frames completed before the next screen refresh, but variation in screen refresh rates makes it impossible with a fixed timer. No matter what the timer interval is you'll slowly drift out of the timing window for a frame and end up dropping one. This would happen even if the timer fired with millisecond accuracy, which it won't (as developers have <a href="http://www.nczonline.net/blog/2011/05/03/better-javascript-animations-with-requestanimationframe/">discovered</a>) -- timer resolution varies depending on whether the machine is on battery vs. plugged in, can be affected by background tabs hogging resources, etc. Even if this is rare (say, every 16 frames because you were off by a millisecond) you'll notice: you'll be dropping several frames a second. You'll also be doing the work to generate frames that never get displayed, which wastes power and CPU time you could be spending doing other things in your application.</p>

<p>Different displays have different refresh rates: 60Hz is common, but some phones are 59Hz, some laptops drop to 50Hz in low-power mode, some desktop monitors are 70Hz.</p>
<p>We tend to focus on frames per second (FPS) when discussing rendering performance, but variance can be an even bigger problem. Our eyes notice the tiny, irregular hitches in animation that a poorly timed animation can produce.</p>
<p>The way to get correctly timed animation frames is with <a href="http://docs.webplatform.org/wiki/apis/timing/methods/requestAnimationFrame"><code>requestAnimationFrame</code></a>. When you use this API, you're asking the browser for an animation frame. Your callback gets called when the browser is soon going to produce a new frame. This happens no matter what the refresh rate is.</p>
<p><code>requestAnimationFrame</code> has other nice properties too:</p>
<ul>
<li>Animations in background tabs get paused, conserving system resources and battery life.</li>
<li>If the system can't handle rendering at the screen's refresh rate, it can throttle animations and produce the callback less frequently (say, 30 times a second on a 60Hz screen). While this drops framerate in half, it keeps the animation consistent -- and as stated above, our eyes are much more attuned to variance than framerate. A steady 30Hz looks better than 60Hz that misses a few frames a second.</li>
</ul>
<p><code>requestAnimationFrame</code> has been discussed all over the place already, so refer to articles like <a href="http://creativejs.com/resources/requestanimationframe/">this one from creative JS</a> for more info on it, but it's an important first step to smooth animation.</p>


<h3 id="toc-jank-cssanimation">CSS Animation (Tom)</h3>
<p>What's better than lightweight JS in your event and rAF callbacks? No JS.</p>
<p>Earlier we said there's no silver bullet for avoiding interrupting your rAF callbacks, but you can use CSS animation to avoid the need for them entirely. On Chrome for Android in particular (and other browsers are working on similar features), CSS animations have the very desirable property that the browser can often run them even if JavaScript is running.</p>
<p>There's an implicit statement in the above section on jank: browsers can only do one thing at a time. This isn't strictly true, but it's a good working assumption to have: at any given time the browser can be running JS, performing layout, or painting, but only one at a time. This can be verified in the Timeline view of Dev Tools. One of the exceptions to this rule is CSS animations on Chrome for Android (and soon desktop Chrome, though not yet).</p>
<p>When possible, using a CSS animation both simplifies your application and lets animations run smoothly, even while JavaScript runs.</p>

<h2>Diagnosing slow paint times</h2>
<p>Let&rsquo;s quickly recall what a paint is. In the life of a web page we generally perform three core tasks: fetching resources, parsing and tokenizing these resources (HTML/CSS/JS) and finally drawings things to screen.</p>

<img src="images/life.png" alt="">

<p>In a browser&#39;s paint phase, we have a tree of visual elements in the order in which they will be displayed called the render tree. This is traversed and a &quot;paint&quot; method called to display content to the screen. Painting can either be global (against the whole tree) or incremental (partial). The basic flow of a rendering engine can be seen below, taken from Tali Garsiel&rsquo;s &ldquo;<a href="http://taligarsiel.com/Projects/howbrowserswork1.htm">How Browsers Work</a>&rdquo;.</p>
<p><img alt="" class="alignleft size-full wp-image-5093" height="66" src="images/image00.png"/></p>

<p>Who should you care about this? Well, it's important to be aware that the browser has to do a lot of work in order to draw things to the screen. Anything you do to increase the complexity of that task (e.g forcing the entire layout of the page to be recalculated) has the potential to introduce jank to your pages. You ideally want to avoid this. So, let's talk about some tooling that can help you measure these slowdowns.</p>

<h3>DevTools: Timeline 101</h3>

<p>The Timeline panel provides an overview of where time is spent loading up your web application such as how long it takes to process DOM events, render page layouts or paint elements to the screen. It allows you to drill down into three separate facets that can help discover why your application is slow: Events, Frames and actual Memory usage.</p>

 <p>For this article, we're interested in Frames mode, which gives you insight into the tasks Chrome had to perform to generate a single frame (update) of your application for presentation on the screen.</p>

<img src="images/frames.png"/>

<p>Timeline won't display any data by default but you can begin a recording session with it by opening your app and clicking on the gray circle at the bottom of the pane - using the Cmd/Ctrl+E shortcut will also trigger a record. This record button will turn from gray to red and the Timeline will begin to capture the timelines for your page. If you don't have a site or app to hand, try out http://inception-explained.com as this is a site with jank.
</p>

<img src="images/timeline.png"/>

<p>Complete a few actions inside your app (or the one suggested, such as scrolling) and after a few seconds, click the button again to stop recording.</p>

<img src="images/Screen Shot 2013-05-27 at 14.30.39.png">

<p>The Summary view (at the top of the Timeline) displays horizontal bars representing the network and HTML parsing (blue), JavaScript (yellow), style recalculation and layout (purple) and painting and compositing (green) events for your page. Repaints are browser events invoked by responses to visual changes such as window resizes or scrolls.Recalculations occur due to modifications of CSS properties whilst Layout events (or reflows) are due to changes in element position.</p>

<img src="images/Screen Shot 2013-05-27 at 14.34.23.png" alt="">

<p>Hovering over a record will display an extended tooltip with details about the time taken to complete it - these have so much useful information in there, so do pay attention to them, especially the Call Stack</p>

<p>The Timeline also identifies when your application causes a forced asynchronous layout and marks these records with yellow warning icon.</p>

<img src="images/layout.jpg" alt="">

<h2>What is a repaint?</h2>
<p>During a user&rsquo;s interaction with a page, only <strong>parts </strong>of it will be changed. For example, they may perform an action changing visibility or adding an outline to an element. The actual process of <strong>updating </strong>the screen is known as a repaint. Changes to your page (e.g JavaScript has modified CSS styles) invalidate the rectangle you see on the screen and cause your browser to view it as &quot;damaged&quot; (this is known as a damage rect).</p>
<p>A <strong>repaint </strong>is an expensive operation performance wise and can make your page look sluggish, which you ideally want to avoid. In Chrome, we keep an eye on what in the screen needs to be changed, creating a damage rectangle with the coordinates to parts of the page requiring repainting.</p>
<p>We save the old rectangle, prior to your changes, as a bitmap and then only paint the delta between the new rectangle and the old one. If you notice that there are particular areas of a page that require a lot of repainting, it&rsquo;s useful to investigate what can be done to reduce the painting cost.</p>
<h2>Diagnosing Slow Paint Times - A Timeline Workflow</h2>
<p>Before we explore an updated workflow for reducing repaints and jank, let&rsquo;s first look at a new shortcut that was introduced to help with this.</p>

<h3>Pro-tip: we have a shortcut for quickly hiding DOM elements</h3>
<p>We recently added helper to the DevTools (Canary) allowing you to easily toggle setting <code>visibility:hidden</code> on an element. When this style is applied to an element, it isn&rsquo;t painted but does maintain the page layout in an unchanged state.</p>
<p>To use the shortcut, select a DOM element in the Elements panel and then press the H key. When paired with paint rectangles and the Timeline, you can easily evaluate which DOM elements are spending long on paint time.</p>
<p><img alt="" class="alignnone size-large wp-image-5103" height="391" src="images/image03-1024x669.png"  /></p>


<h3>Pro-tip: use continuous painting mode to diagnose slow styles</h3>
<p>Some of the reasons Chrome repaints areas of the page include user-interactions which cause style changes to DOM elements, DOM nodes being changes (forcing layout recalculation) and any other operatons which cause the layout of the page to be changed.</p>
<p>It can be useful to understand why repaints occur in your page. "Continuous page repainting" is a tool we recently introduced to the Settings panel which helps identify elements that have a high paint cost on the page. It forces the page into constantly repainting, providing a counter that shows just how much paint work is being done. You can use the H shortcut mentioned above to toggle different styles (keep an eye on the counter!) to diagnose what is causing the slowdown. </p>
<p><img alt="" class="alignnone size-large wp-image-5103" height="391" src="images/continuous.png"  /></p>


<p><strong>Workflow</strong></p>
<p>Let&rsquo;s now look at what an expanded workflow for diagnosing paint and jank issues might look like:</p>
<ol>
	<li>Open up your page, launch the Chrome DevTools and switch to the Timeline panel. Hit record and interact with your page the same way your user would.</li>
	<li>Check the Timeline for any frames that went over budget (i.e that are below that ideal 60fps). If you&rsquo;re close to the budget, then you&rsquo;re likely way over budget on mobile. Aim to complete all of your work within 10ms to have some margin. <strong>Note:</strong> This margin is for slower devices and you should almost certainly run this analysis on mobile using <a href="https://developers.google.com/chrome-developer-tools/docs/remote-debugging">remote debugging</a> (if building for mobile, which you should be!). &nbsp;<p><a href="image051.png"><img alt="" class="alignnone size-full wp-image-5105" height="173" src="images/image051.png" title="image05" width="489" /></a></p></li>
	<li>Once you&rsquo;ve noticed you have a janky frame, check what the cause of it was. Was it a huge paint? CSS layout issue? JavaScript</li>
	<li><strong>Fix the problem. If it was a paint or layout issue:</strong>
		<ol>
			<li>Go to Settings and enable "continuous page repainting".</li>
			<li>Walk through the DOM tree, hiding non-essential elements using the hide (H) shortcut. You might discover hiding particular element(s) make a large difference to your paint times and frame rate.</li>
			<li>We now know there is something about an element slowing painting down. Uncheck styles that could have an impact on paint time (e.g box-shadow) for the element and check your frame rate again.</li>
			<li>Continue until you&rsquo;ve located the style responsible for the slow-down.</li>
		</ol>
	</li>
	<li>Rinse and repeat</li>
</ol>
<p>Especially on sites that rely heavily on scroll, you might discover that your main content is relying on <code>overflow:scroll</code>. This is a real challenge as this scrolling isn&rsquo;t GPU accelerated in any way so the content is repainted whenever your user scrolls. You can work around such issues using normal page scroll (<code>overflow:visible</code>) and position:fixed.</p>

<h2>Timeline reference</h2>
<ul>
<li>Composite Layer - Chrome's rendering engine composited image layers.</li>
<li>Image Decode - An image resource was decoded.</li>
<li>Image Resize - An image was resized from its native dimensions.</li>
<li>Paint - Composited layers were painted to a region of the display. Hovering over a Paint record highlights the region of the display that was updated.</li>
<li>Invalidate layout - The page layout was invalidated by a DOM change.</li>
<li>Layout - A page layout was executed.</li>
<li>Recalculate style - Chrome recalculated element styles.</li>
<li>Scroll - The content of nested view was scrolled.</li>
</ul>

<h2>GPU acceleration</h2>

<p>The next thing we're going to look at is GPU acceleration. In the past, Web browsers have relied pretty heavily on the CPU to render pages. This involved two things: firstly, painting elements into a bunch of textures, called layers; and secondly, compositing all of those layers together to the final picture seen on screen.
Over the past few years, however, we've found that getting the GPU involved in the compositing process can lead to some significant speeding up. The premise is that, while the textures are still painted on the CPU, they can be uploaded to the GPU for compositing. Assuming that all we do on future frames is move elements around (using CSS transitions or animations) or change their opacity, we simply provide these changes to the GPU and it takes care of the rest. We essentially avoid having to give the GPU any new graphics; rather, we just ask it to move existing ones around. This is something that the GPU is exceptionally quick at doing, thus improving performance overall.</p>

<p>There is no guarantee that this hardware compositing will be available and enabled on a given platform, but if it is available the first time you use, say, a 3D transform on an element, then it will be enabled in Chrome. Many developers use the translateZ hack to do just that. The other side effect of using this hack is that the element in question will get its own layer, which may or may not be what you want. It can be very useful to effectively isolate an element so that it doesn't affect others as and when it gets repainted. It's worth remembering that the uploading of these textures from system memory to the video memory is not necessarily very quick. The more layers you have, the more textures need to be uploaded and the more layers that will need to be managed, so it's best not to overdo it.</p>

<p>Another great setting in Developer Tools that can help here is “Show composited layer borders.” This feature will give you insight into those DOM elements that are being manipulated at the GPU level.</p>

<p>If an element is taking advantage of the GPU acceleration, you'll see an orange border around it with this on. Now as we scroll through, we don't really see any use of composited layers on this page — not when we click “Scroll to top” or otherwise.
Chrome is getting better at automatically handling layer promotion in the background; but, as mentioned, developers sometimes use the translateZ hack to create a composited layer. Below is one site's homepage with translateZ(0) applied to all pins. It's not hitting 60 FPS, but it is getting closer to a consistent 30 FPS on desktop, which is actually not bad.</p>

<p><img src="images/Screen-Shot-2013-05-15-at-19.03.13.png"/></p>

<p>Remember to test on both desktop and mobile, though; their performance characteristics vary wildly. Use the timeline in both, and watch your paint time chart in Continuous Paint mode to evaluate how fast you're busting your budget.
Again, don't use this hack on every element on the page - it might pass muster on desktop, but it won't on mobile. The reason is that there is increased video memory usage and an increased layer management cost, both of which could have a negative impact on performance. Instead, use hardware compositing only to isolate elements where the paint cost is measurably high.</p>

<h2>Additional Tools</h2>
<h3>Show paint rectangles</h3>
<p>Under &lsquo;Rendering&rsquo; in the Settings cog, you can enable a feature called &lsquo;Show paint rectangles&rsquo; to help you visually see the area repainted in each frame. With this feature enabled, it can become easy to visualize what slows pages down. You want to keep the areas being repainted as small as possible.</p>
<p>&nbsp;</p>
<p><a href="image06.png"><img alt="" class="alignnone size-large wp-image-5107" height="397" src="images/image06-1024x678.png" /></a></p>
<h3>FPS counter</h3>
<p>An older, but equally as useful tool for visualizing frame rate and jank is the real-time FPS counter. This can be enabled in the DevTools by going to the Settings menu and checking Show FPS meter.</p>
<p style="text-align: center;"><a href="image04.png"><img alt="" class="alignnone size-full wp-image-5108" height="119" src="images/image04.png" title="image04" width="186" /></a></p>
<p>When activated, you will see a dark box in the top-right corner of your page with frame statistics. The counter can be used during live editing to diagnose what in your page is causing a drop-off in frame rate without having to switch back and forth with the Timeline view.</p>
<p><img alt="" class="alignnone size-large wp-image-5109" height="389" src="images/image01-1024x665.png" title="image01" width="600" /></p>
<p>Keep in mind that just tracking the FPS counter may lead to you not noticing frames with intermittent jank. Be careful when using the content. It is also worth noting that FPS on desktop does not equal FPS on devices and special care should be taken to profile the performance there too.</p>

<h3>Tutorial: Going Glitch-Free</h3>

<p>
Let's look at an animation sample with janky animation and see if we can improve it to better visualize what it means to be jank-free.</p>

<img src="images/pre.png"/>

<p>1. Open up <a href="http://jsfiddle.net/AxEJY/">http://jsfiddle.net/AxEJY/</a>. </p>
<p>2. Click 'animate!'. As you can see there is a visual break in motion, resulting in a suboptimal animation. We can record a Timeline session during the animation of this page to confirm that we have an issue hitting an optimal frame rate. </p>
<p>3. Let's see what's causing things to slow down. Here's the JavaScript for our animation as well as the CSS.

<p>JavaScript:</p>

<pre>
// setup
var rAF = window.requestAnimationFrame;
var startBtn = document.querySelector('.animate');
var stopBtn = document.querySelector('.stop');

// state
window.running = false;

// add listeners
// start
startBtn.addEventListener("click", function(e){
   running = true;
   rAF(update); 
});

// stop
stopBtn.addEventListener("click", function(e){
   running = false; 
});

// Set the heights for all these
// movers in simple CSS style.top
var movers = document.querySelectorAll('.mover');
(function init() {
    for (var m = 0; m < movers.length; m++) {
        movers[m].style.top = (m * 20 + 50) + 'px';
    }
})();

// animation loop
function update(timestamp) {
    for (var m = 0; m < movers.length; m++) {
            movers[m].style.left = ((Math.sin(movers[m].offsetTop + timestamp / 1000) + 1) * 500) + 'px';
        }

    if (window.running){
        rAF(update);
    }
};
rAF(update);
</pre>

<p>CSS:</p>
<pre>
.mover {
  background:url(http://jankfree.org/velocity-europe/examples/too-much-layout/particle.png);
  height:100px;
  width:100px;
  position:absolute;
  z-index:0;
}

input {
  z-index:2;
  font-size:25pt;
  height:100px;
  width:100px;
  display:inline-block;
}
</pre>


    <h2>Analyze the recording</h2>

    <p>
        Looking at the recording of the first few frames it's clear that each one is taking over 300ms to complete. If you hover your mouse over one of the frames a pop-up appears showing additional details about the frame.</p>

       <div class="screenshot"> <img src="images/frame-rate.png" alt=""></div>
    <p>
        Locate an Animation Frame Fired record and notice the yellow warning icon next to it, indicating a forced synchronous layout. The icon is slightly dimmed indicating that one of its child records contains the offending code, rather than this record itself. Expand the Animation Frame Fired to view its children.
    </p>

    <div class="screenshot"><img src="images/recording-1.png"></div>

    <p>
        The child records show a long, repeating pattern of <strong>Recalculate Style</strong> and <strong>Layout</strong> records. Each layout record is a result of the style recalculation that, in turn, is a result of the <code>requestAnimationFrame()</code> handler requesting the value of <code>offsetTop</code> for each image on the page. Hover your mouse over one of the Layout records and click the link for sources.js next to the Layout Forced property.
    
    <div class="screenshot"><img src="images/layout-warning-hover.png"></div>
    
    p>
        The Sources panel opens at line 43 of the source file at the <code>update()</code> function, which is the <code>requestAnimationCallback()</code> callback handler. The handler computes the image's <code>left</code> CSS style proeprty on the the image's <code>offsetTop</code> value. This forces Chrome to perform a new layout immediately to make sure it provides the correct value.
    </p>

    <pre class="prettyprint lang-js">
// Animation loop
function update(timestamp) {
    for(var m = 0; m < movers.length; m++) {
        movers[m].style.left = ((Math.sin(movers[m].offsetTop + timestamp/1000)+1) * 500) + 'px';
        }
    raf = window.requestAnimationFrame(update);
};
</pre>

<p>We know that forcing a page layout during every animation frame is slowing things down. Now we can try to fix the problem directly in DevTools.</p>

<h2>Apply fix within DevTools</h2>

    <p>Now that we have an idea what's causing the performance issues, we can modify the JavaScript file directly in the Sources panel and test our changes right away.</p>
    
    <ol>
        <li>In the Sources panel that was opened previously, replace line 43 with the following code.</li>
            <code style="prettyprint" lang-js><pre>movers[m].style.left = ((Math.sin(m + timestamp/1000)+1) * 500) + 'px';</pre></code>
            <p>This version computes each image's <code>left</code> style property on its index in its holding array instead of on a layout-dependent property (<code>offsetWidth</code>).</p>

        <li>Save your changes by pressing Cmd-S or Ctrl-S.</li>
    </ol>

<h2>Verify with another recording</h2>

        <p>The animation is clearly faster and smoother than before, but it's always good practice to measure the difference with another recording. It should look something like the recording below.</p>

        <div class="screenshot"><img src="images/fixed.png"></div>


<p>Try it out. The corrected code for this sample can be found at <a href="http://jsfiddle.net/k4yM3/">http://jsfiddle.net/k4yM3/</a> and now performs at close to 60fps.</p>

<p><img src="images/post.png"/></p>

<p>Re-do your Timeline recording and you will now see that performance has greatly improved.</p>


<h2>Pro-tips:</h2>

<p>Your JavaScript can annotate DevTools Timeline recordings using console.timeStamp(). See below for 'Adding result', an annotation added by our code during profiling:</p>

<img src="images/timestamp.png" alt="">

<p>Your code can also use console.time() & console.timeEnd() to mark ranges in DevTools Timeline recordings:
</p>

<img src="images/protip3.jpg" alt="">


<p>If you enable "Show CPU activity on the ruler", you can overlay the CPU activity in your Timeline recordings. With this on, the light bars indicate the CPU was busy. If you hover over a CPU bar, this highlights the region during which the CPU was active.</p>

<img src="images/Screen Shot 2013-05-27 at 16.56.06.png" alt="">

<p>If you would like to drill down to records of a particular type, you can do this by using the Ctrl + F shortcut (Cmd + F on Mac) when in the Timeline. Just enter in the name of the record type (e.g 'scroll') and Timeline will only show the records containing the term.</p>

<img src="images/Screen Shot 2013-05-27 at 17.01.35.png" alt="">

<p>In case you're wondering what those transparent bars in the Timeline mean, these hollow frames correspond to one of two things: your JavaScript on the main thread was busy doing something we forgot to show (instrument) in the DevTools or you were bottlenecked by your GPU.</p>

<img src="images/trans.png" alt="">




<h2 id="remote-debugging-overview">Remote debugging on Android</h2>

<p>The experience of your web content on mobile operates very differently than what
users experience on the desktop, but luckily much of the performance tooling we've discussed is available via remote debugging too.  The Google Chrome DevTools allow you to inspect,
debug, and analyze the on-device experience with the full suite of tools you're
used to, meaning you can use the Chrome DevTools on your development machine to debug a page on
your mobile device.</p>

<p><div class="screenshot"><img width="722" alt="Debugging Chrome for Android using the Chrome Developer Tools" src="images/remote-debug-overview.png"/></div></p>

<p>Debugging occurs over USB and as long as your mobile device is connected to your development 
machine, you can view and change HTML, scripts and styles until you get a bug-free page that
behaves perfectly on all devices.</p>

<p>A streamlined version of the debugging process is available in preview versions of Chrome 
(including the the Chrome Beta and Dev update channels and Chrome Canary). Stable versions of Chrome require a few extra steps. Follow the steps for your version of Chrome:</p>

<ul>
<li>Chrome Beta, Dev or Canary. See <a href="remote-debugging-beta">Remote debugging with Chrome and ADBPlugin</a></li>
<li>Chrome Stable. See <a href="remote-debugging-stable">Remote debugging with Chrome Stable</a></li>
</ul>

<p>When debugging a web application served from your development machine, you can use 
<a href="#reverse-port-forwarding">reverse port forwarding</a> to allow the mobile device to access a site from the development machine 
over USB.</p>

<h2 id="remote-debugging-beta">Remote debugging with Chrome and ADBPlugin</h2>

<p><strong>To start debugging, you need:</strong></p>

<ul>
<li>An Android phone or tablet with <a href="https://play.google.com/store/apps/details?id=com.android.chrome&amp;hl=en">Chrome for Android</a> or <a href="https://play.google.com/store/apps/details?id=com.chrome.beta">Chrome Beta for Android</a> installed from Google Play.</li>
<li>A USB cable to plug in your device. (Windows users will also need to install an <a href="http://developer.android.com/tools/extras/oem-usb.html" target="_blank">appropriate USB device driver</a>.)</li>
<li><a href="https://www.google.com/intl/en/chrome/browser/beta.html">Chrome Beta</a>,
<a href="http://www.chromium.org/getting-involved/dev-channel">Chrome Dev</a>, or 
<a href="https://www.google.com/intl/en/chrome/browser/canary.html">Chrome Canary</a>
installed on your development machine.</li>
<li><a href="#install-adbplugin">ADBPlugin</a> installed as a Chrome extension on your development machine.</li>
</ul>
<aside class="note">If you're using a stable release of Chrome, see <a href="remote-debugging-stable">Remote debugging with Chrome Stable</a>.</aside>


<h3 id="install-adbplugin">1. Install ADBPlugin</h3>

<p>ADBPlugin is a Chrome extension that simplifies the process of setting up remote debugging. ADBPlugin includes the Android Debug Bridge (ADB), which lets you debug the device over USB from your development machine. It provides the following features:</p>
<ul>
<li>Bundles ADB so you don't have to install the full Android SDK.</li>
<li>Provides a UI for easily starting and stopping the ADB daemon, and viewing connected devices.</li>
</ul>

Visit <a href="https://github.com/GoogleChrome/ADBPlugin/#readme" target="_blank">ADBPlugin on github</a> to download and install ADBPlugin.

<h3 id="enable-usb-debugging">2. Enable USB debugging on your device</h3>

<p>In order to debug over USB, you need to setup your Android device for
development.
Enable USB debugging on your device then system to detect your device as mentioned in the
guide.</p>

<p><strong>To enable USB debugging:</strong></p>

<ul>
<li>On most devices running Android 3.2 or older, you can find the option under
<strong>Settings > Applications > Development.</strong></li>
<li>On Android 4.0 and newer, it's in <strong>Settings > Developer </strong>options.</li>
<li>On Android 4.2 and newer, Developer options is hidden by default. To make it
available, go to <strong>Settings > About phone</strong> and tap Build number seven times.
Return to the previous screen to find Developer options.</li>
</ul>

<p><div class="screenshot"><img width="500" alt="USB debugging settings in Developer options" src="images/image_4.png"/></div></p>

<p>If you are developing on Windows, you need to install the appropriate USB driver for your device. See <a href="http://developer.android.com/tools/extras/oem-usb.html" target="_blank">OEM USB Drivers</a> on the Android Developers site.</p>

<p>For more information see <a href="http://developer.android.com/tools/device.html#setting-up">Setting up a Device for Development</a> on the Android Developers site.</p>

<h3 id="connect-device-via-usb">3. Connect your device via USB</h3>

<ol>
<li>Connect your mobile device to the development machine using a USB cable. </li>
<li>On the mobile device, launch Chrome. Open <b>Settings > Advanced > Developer Tools</b>
and check the <b>Enable USB Web debugging</b> option as shown here:</li>

<p><div class="screenshot"><img width="220" alt="Enable USB Web Debugging in Chrome for Android" src="images/image_5.png"/></div></p>
</ol>

<h3 id="start-debugging-with-adbplugin">4. Start debugging with ADBPlugin </h3>

<p>When ADBPlugin is installed, a gray Android menu icon appears beside the Chrome menu.</p>

<p><strong>To start debugging:</strong></p>

<ol>
<li><p>Click the Android icon, then click <b>Start ADB</b>.</p>

<p><img class="screenshot" width="149" alt="ADBPlugin menu" src="images/adb-plugin-menu.png"/></p>

<p>Once ADB has started, the menu icon turns green and displays the number of currently connected devices, if any.</p>

<p><img class="screenshot" width="149" alt="ADBPlugin menu" src="images/adb-plugin-menu-active.png"/></p>

</li>
<li>Click <b>View Devices</b> to open the <b>chrome://inspect</b> page that displays each connected device and its tabs.</li>
<li>Find the mobile device tab you want to debug and Click the <b>inspect</b> link next to its URL.</li>
</ol>

<p>If you <em>don't</em> see any connected devices:</p>

<ul>
<li>Check that your device is connected to USB.</li>
<li>Ensure your device is listed as available by issuing the <code>adb devices</code>
command. If not, check that you have USB debugging enabled on your
device.</li>
<li>Ensure that USB debugging is enabled in the Chrome for Android settings.</li>
</ul>

<h3 id="debug-your-app">5. Debug Your Application</h3>

<p><div class="screenshot"><img width="700" alt="Inspecting a remote page using the Chrome Developer Tools" src="images/elements-panel.png"/></div></p>

<p>For example, inspect an element in the page you have selected and 
the element highlights in Chrome mobile on your device in real time.</p>


<p>Similarly, editing scripts or executing commands from the DevTools console 
affects the page being inspected on your device. You can also also use all of 
the other panels, such as 
<a href="/chrome-developer-tools/docs/timeline">Timeline</a> and
<a href="/chrome-developer-tools/docs/profiles">Profiles</a>.</p>

<h3 id="notes">Notes</h3>

<ul>
<li>You may notice that the version of the DevTools you have access to during
remote debugging differs to the version you have running on your development machine. This is
because the tools are synchronized with the Chrome version on the Android
device being used.</li>
<li>Because we're connected over USB, you can keep the device on a real cellular
network, and view the network waterfall in the Network panel under actual
network conditions</li>
<li>The hardware on mobile devices often runs your content much slower, so use the
<a href="/chrome-developer-tools/docs/timeline">Timeline</a> to analyze how to optimize
rendering and CPU for the best effect.</li>
<li>If you're running a web server on your development machine, and network restrictions prevent 
your mobile device from accessing the server, see 
<a href="#reverse-port-forwarding">reverse port forwarding</a></li>.
</ul>



<h2>Conclusions</h2>

<p>Jank are some of the trickiest bugs to nail down but they can be the most trying and have a direct effect on user happiness. Pursue jank issues relentlessly and develop a keen eye for identifying it. There's no fixed way to identify and fix these problems otherwise. No hard and fast rules.</p>

<p>Although at the time of writing, Chrome has the best tools to profile paint performance, we strongly recommend testing and measuring your pages in other browsers to get a feel for what your own users might experience (where feasible). Performance can vary massively between them, and a performance smell in one browser might not be present in another.</p>

<p>Measure for yourself, understand the abstractions, know your browser's internals. In time, we hope that the cross- browser tooling for this area improves so that developers can get an accurate picture of rendering performance, regardless of the browser being used.</p>

<p>Performance is important. Not all machines are created equal, and the fast machines that developers work on might not have the performance problems encountered on the devices of real users. Frame rate in particular can have a big impact on engagement and, consequently, on a project's success. Luckily, a lot of great tools out there can help with that.</p>

<p>Be sure to measure paint performance on both desktop and mobile. If all goes well, your users will end up with snappier, more silky-smooth experiences, regardless of the device they're using.To learn more about optimizing the paint performance of your pages, check out http://jankfree.org and our official Chrome DevTools <a href="https://developers.google.com/chrome-developer-tools/docs/using-timeline">documentation</a>.</p>



