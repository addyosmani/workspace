
<h1>Find And Fix Mobile Web Rendering Issues</h1>


<p>The performance conversation is starting to change.</p>

<p>We've been comparing the web's performance on mobile to the performance of native and it's no longer just important to consider how quickly a site loads but also how well it renders and runs. We all want our user experiences on the web (whatever device we're using to access it) to be <strong>snappy</strong>, smooth and delightful. What this means is that even if the browser is busy <a href="http://taligarsiel.com/Projects/howbrowserswork1.htm#The_rendering_engine">rendering</a> the page (i.e drawing it) or loading in content, the user should still be able to scroll around and interact with it without any slow-down - no one likes seeing visual glitchyness!.</p>

<p>This can be a challenge as mobile devices are underpowered when compared to our shiny desktop systems. Painting the page to the screen takes longer, loading network resources takes longer, decoding images takes longer and executing scripts takes longer. Your performance on mobile is almost never equal to your performance on desktop. Some would even say it can be between 5 to 10 times slower.</p>

<p>Large sites, including <a href="https://twitter.com/igrigorik/status/300226402496704512">Facebook</a> and <a href="http://code.flickr.net/2013/06/04/adventures-in-jank-busting-parallax-performance-and-the-new-flickr-home-page/">Flickr</a> are starting to care about this side of performance - the art of efficient rendering. They've found it can affect not only your user experience but also your user engagement. Measurement is the most important part of any performance profiling and where possible, always check your sites and apps using the tooling in other browsers to double-check if your slowdown is browser-specific.</p>

<h2>Where does rendering performance fit in?</h2>

<p>There are three key factors to performance on the web: network, compute and render. In order to appreciate where rendering performance fits in, let's briefly review them.</p> 

<p>Network</p>

<p>You always want to keep an eye on the number of network requests your site is making. If you aren't on HTTP 2.0, each file is going to end up being requested separately and these requests may have quite a large latency on them. They'll also keep the radio alive on your device, which is the second biggest power-drainer after your screen. Keeping those requests down means we can minimize how long the radio is kept on. Also keep in mind that bandwidth and latency are different things so even if you're on a 3/4G connection, that doesn't mean you're going to improve your latency. This is one reason why best practices like concatenating your scripts, inlining CSS and using image sprite maps are so important.</p>

<p>A large amount of the web's traffic is images - well over half of it. In many parts of the world, users have fixed data caps on mobile meaning that if you go over this cap (e.g 1GB) you'll end up having to pay more. This is one reason it's important for images being served to be optimized as much as possible. At the moment newer formats like WebP offer some substantial file size savings compared to the equivalent quality of a JPEG or PNG. I say quality because you can usually beat a codec if you lower your quality in another format. For those lucky enough to be running their own servers, some of my colleagues at Google recommend trying out mod_pagespeed - a tool which can automatically optimize your site, handling minification and image optimization without any effort. Nice, right?</p>

<p>Compute</p>

<p>We refer to JavaScript processing as "compute". All of it runs inside of a dedicated engine in the browser (e.g in Chrome we've got V8) and in many cases these engines are blazingly fast. One of the reasons it's so fast is that the engine keeps an eye on your code and swaps it out with optimized lower-level code where possible.</p>

<p>JavaScript developers regularly worry about memory leaks being introduced by their code. Since we don't handle the retention and release of memory ourselves and leave this up to the garbage collector, we have to be careful not to do silly things like leaving references to objects we no longer need hanging around. Memory usage from all of these hanging objects otherwise grows over time and that's basically what causes a memory leak - the garbage collector not being able to release something because it thinks you may still need it. The browser developer tools in Chrome, Opera and Firefox can point out where garbage collection has occurred so you can find out where and why you're generating garbage and attempt to address this.</p>

<p>The last thing to keep in mind is something we call deoptimization. This happens when there some of the design designs you've made in your code have led to the engine having to back out of an optimized path for slower code. There are tons of reasons why this can happen and it varies from engine to engine. In Chrome and Opera, you can get a little mileage using a standalone version of V8 called d8. It can inform you what JavaScript is being deoptimized, giving you a chance to reconsider how you've written some of your code.</p>

<p>Render</p>


<p>Rendering perf. has only recently come under the spotlight for many web developers and we're going to devote the rest of this chapter to understanding it. Each of your pages is going to contain a DOM tree (representing your page's content and structure). Painting the DOM to pixels on the screen can be one of the most expensive operations in your page's lifecycle. Any extra effort that's involved in doing this as your user interacts with your page can result in a visual slow-down. Lots of things can trigger this - scrolling, injecting new content into the page, layout thrasing (any changes that modify the layout of your page), interacting with the UI - pretty much any changes that need to be painted. </p>


<p>As we'll discuss in more depth soon, painting isn't just about user interactions. It also includes the effort the browser has to put in to decode images (if you give it a JPEG, this has to be turned into a Bitmap) as well as resizing. If you give the browser a 1024px wide image which you're resizing down to 360px using CSS, that's going to be a lot less efficient than simply providing a prescaled 360px wide image to it. The Chrome and Opera DevTools can give you some more insights into image decode times in the Timeline.</p>


<h2>Jank - Visual slowdown that impacts engagement</h2>

<p>The human eye perceives a continuous stream of information. It does not naturally see motion as a series of frames.  In the worlds of animation, film and gaming, using a series of still frames to simulate motion create some interesting perceptual artifacts - especially if the frames are played back too slowly. This is because when you have a varying frame rate that isn't constant, our eyes perceive jerkiness and jitter, not smoothness in the motion, and what we see can appear to flicker.</p>

<p>For an optimal user experience, animations need to be silky, <a href="http://www.html5rocks.com/en/tutorials/speed/scrolling/">scrolling</a> must be buttery-smooth and your page needs to contain little to no jank - a term that means a <b>disruption</b> in consistent frame rate that manifests itself visually.</p>

<p>On the web, a low frame rate (and janky experience) means that individual frames being rendered by the browser can be made out by the human eye. Giving users a jank-free experience often comes down to offering an experience that can run at <strong>60fps</strong> on sites and web apps, not just games and animations. At 60fps, you have 16.66ms to complete absolutely everything in for Chrome to display a frame of your page - that's logic processing, painting, layout, image decoding, compositing..everything. Once you factor in mischellaneous browser processes, this number looks more like 8-10ms and blowing this budget can mean your users are more likely to see jank in their pages.</p>

<p>What's magical about the number 60? Well, we say 60fps as this matches the refresh rate of those of the devices we use today. Animations should match the refresh of the device they are being used on. Phones are usually 55-60hz. Laptops 58-60hz (although 50hz in low power mode) and most monitors are 50-62hz.</p>

<p>To hit 60fps, we sometimes need to go&nbsp;<strong>beyond </strong>JavaScript as the sole performance bottleneck for our pages and spend more time investigating paint and layout issues - styles might actually be the core cause of our sluggish performance.

<p>Some of the core causes of jank in sites and applications include:</p>

<ul>
	<li>Heavy paint times for your DOM elements</li>
	<li>Unnecessary image resizes (because you haven't pre-scaled to the size you need)</li>
	<li>Long image-decodes (e.g decoding PNG/JPEG)</li>
	<li>Unexpected layer invalidations</li>
	<li>Garbage collector runs</li>
	<li>Network requests (e.g processing an XHR)</li>
	<li>Heavy animation or data processing. </li>
	<li>Input handlers with a heavy amount of JavaScript. One common mistake is adding a lot of JavaScript to rearrange the page in an onscroll handler which impacts paint times.</li>
</ul>

<h2>requestAnimationFrame</h2>

<p><code>setInterval</code> and <code>setTimeout</code> are regularly used to create animations every 16 milliseconds. This comes with it's own challenges, but two are of particular note: refresh rates differ from device to device (e.g the refresh rate on your phone may not necessarily be the refresh rate on your desktop) and secondly, timer resolution from JavaScript is only on the order of a few milliseconds</p>

<p>In order for the next screen refresh to occur, you need a completed animation frame with all JavaScript, DOM manipulation, painting and layout to be ready. It can be really hard to get animation frames complete before the next refresh when you're working with low timer resolution and variations in screen refresh rates make this near impossible with a fixed timer. Regardless of what your timer interval is, you'll eventually move out of your timing window for a frame and will drop them meaning users may see a visual drop in smoothness. You'll also end up doing a bunch of work to generate frames that never get shown, wasting critical battery and CPU time.</p>

<p>You may have noticed that we've been caring about frame rate so far when talking about rendering performance - variance has the potential to be a larger issue because as I mentioned, our eyes do notice those little glitches in motion and these tend to come with poorly timed animations. The ebst way to get timed animation frames that are accurate is using the <code>requestAnimationFrame</code> (rAF) API. When you use it, you ask the browser to give you an animation frame and your callback gets called when it's going to generate a new frame. This happens irrespective of the device's refresh rate, which is awesome.</p>

<p>Tom Wiltzius has written about rAF more succinctly than I could on HTML5Rocks, but he's also previously pointed out some of the other nice things it gives you that are quite relevant to mobile: animations in background tabs get paused which can conserve your battery life and if the device can't render at the screen's refresh rate it can actually throttle animations and just generate the callback a little less regularly (e.g 30 times a second rather than 60). Although this might mean you're halfing your frame-rate, it means your animation stays consistent. A constant lower frame rate is better than a varied 60HZ that drops some of its frames.</p>


<h2>CSS Animation</h2>

<p>So, we've talked about rAF but did you know what's even more efficient than lighter JavaScript animation in your callbacks is no JS at all? There's no perfect solution for avoiding interruptions in rAF callbacks, but you can get some mileage using CSS animations to remove the need for them. In browsers like Opera Mobile and Chrome for Android, CSS animations can be run by the browser while JavaScript is running thanks to multi-threading.</p>

<p>One assumption you could have is that at any point during the lifecycle of your page, the browser is performing rendering or running JavaScript but only one at a time. This varies from browser to browser but in the case of CSS animations, because they can be run at the same time at JavaScript you may find that they allow your app's animations to run smoothly even if your JavaScript is blocking.</p>


<h2>Diagnosing slow paint times</h2>
<p>Let&rsquo;s quickly recall what a paint is. In the life of a web page we generally perform three core tasks: fetching resources, parsing and tokenizing these resources (HTML/CSS/JS) and finally drawings things to screen.</p>

<img src="images/life.png" alt="">

<p>In a browser&#39;s paint phase, we have a tree of visual elements in the order in which they will be displayed called the render tree. This is traversed and a &quot;paint&quot; method called to display content to the screen. Painting can either be global (against the whole tree) or incremental (partial). The basic flow of a rendering engine can be seen below, taken from Tali Garsiel&rsquo;s &ldquo;<a href="http://taligarsiel.com/Projects/howbrowserswork1.htm">How Browsers Work</a>&rdquo;.</p>
<p><img alt="" class="alignleft size-full wp-image-5093" height="66" src="images/image00.png"/></p>

<p>Who should you care about this? Well, it's important to be aware that the browser has to do a lot of work in order to draw things to the screen. Anything you do to increase the complexity of that task (e.g forcing the entire layout of the page to be recalculated) has the potential to introduce jank to your pages. You ideally want to avoid this. So, let's talk about some tooling that can help you measure these slowdowns.</p>

<h3>DevTools: Timeline 101</h3>

<p>In Chrome and Opera, the DevTools Timeline panel provides an overview of where time is spent loading up your web application such as how long it takes to process DOM events, render page layouts or paint elements to the screen. It allows you to drill down into three separate facets that can help discover why your application is slow: Events, Frames and actual Memory usage. Right now, we're interested in Frames mode, which gives you insight into the tasks the browser had to perform to generate a single frame (update) of your application for presentation on the screen.</p>

<img src="images/frames.png"/>

<p>Timeline won't display any data by default but you can begin a recording session with it by opening your app and clicking on the gray circle at the bottom of the pane - using the Cmd/Ctrl+E shortcut will also trigger a record. This record button will turn from gray to red and the Timeline will begin to capture the timelines for your page. If you don't have a site or app to hand, try out http://inception-explained.com as this is a site with jank.
</p>

<img src="images/timeline.png"/>

<p>Complete a few actions inside your app (or the one suggested, such as scrolling) and after a few seconds, click the button again to stop recording.</p>

<img src="images/Screen Shot 2013-05-27 at 14.30.39.png">

<p>The Summary view (at the top of the Timeline) displays horizontal bars representing the network and HTML parsing (blue), JavaScript (yellow), style recalculation and layout (purple) and painting and compositing (green) events for your page. Repaints are browser events invoked by responses to visual changes such as window resizes or scrolls.Recalculations occur due to modifications of CSS properties whilst Layout events (or reflows) are due to changes in element position.</p>

<img src="images/Screen Shot 2013-05-27 at 14.34.23.png" alt="">

<p>Hovering over a record will display an extended tooltip with details about the time taken to complete it - these have so much useful information in there, so do pay attention to them, especially the Call Stack</p>

<p>The Timeline also identifies when your application causes a forced asynchronous layout and marks these records with yellow warning icon.</p>

<img src="images/layout.jpg" alt="">

<h2>What is a paint?</h2>
<p>During a user&rsquo;s interaction with a page, only <strong>parts </strong>of it will be changed. For example, they may perform an action changing visibility or adding an outline to an element. The actual process of <strong>updating </strong>the screen is known as a paint. Changes to your page (e.g JavaScript has modified CSS styles) invalidate the rectangle you see on the screen and cause your browser to view it as &quot;damaged&quot; (this is known as a damage rect).</p>
<p>A <strong>paint </strong>is an expensive operation performance wise and can make your page look sluggish, which you ideally want to avoid. In Chrome, we keep an eye on what in the screen needs to be changed, creating a damage rectangle with the coordinates to parts of the page requiring repainting.</p>
<p>We save the old rectangle, prior to your changes, as a bitmap and then only paint the delta between the new rectangle and the old one. If you notice that there are particular areas of a page that require a lot of repainting, it&rsquo;s useful to investigate what can be done to reduce the painting cost.</p>

<h2>Diagnosing Slow Paint Times - A Timeline Workflow</h2>
<p>Before we explore an updated workflow for reducing repaints and jank, let&rsquo;s first look at a new shortcut that was introduced to help with this.</p>

<h3>Pro-tip: we have a shortcut for quickly hiding DOM elements</h3>
<p>We recently added helper to the DevTools (Canary) allowing you to easily toggle setting <code>visibility:hidden</code> on an element. When this style is applied to an element, it isn&rsquo;t painted but does maintain the page layout in an unchanged state.</p>
<p>To use the shortcut, select a DOM element in the Elements panel and then press the H key. When paired with paint rectangles and the Timeline, you can easily evaluate which DOM elements are spending long on paint time.</p>
<p><img alt="" class="alignnone size-large wp-image-5103" height="391" src="images/image03-1024x669.png"  /></p>


<h3>Pro-tip: use continuous painting mode to diagnose slow styles</h3>
<p>Some of the reasons Chrome repaints areas of the page include user-interactions which cause style changes to DOM elements, DOM nodes being changes (forcing layout recalculation) and any other operatons which cause the layout of the page to be changed.</p>
<p>It can be useful to understand why repaints occur in your page. "Continuous page repainting" is a tool we recently introduced to the Settings panel which helps identify elements that have a high paint cost on the page. It forces the page into constantly repainting, providing a counter that shows just how much paint work is being done. You can use the H shortcut mentioned above to toggle different styles (keep an eye on the counter!) to diagnose what is causing the slowdown. </p>
<p><img alt="" class="alignnone size-large wp-image-5103" height="391" src="images/continuous.png"  /></p>


<p><strong>Workflow</strong></p>
<p>Let&rsquo;s now look at what an expanded workflow for diagnosing paint and jank issues might look like:</p>
<ol>
	<li>Open up your page, launch the Chrome DevTools and switch to the Timeline panel. Hit record and interact with your page the same way your user would.</li>
	<li>Check the Timeline for any frames that went over budget (i.e that are below that ideal 60fps). If you&rsquo;re close to the budget, then you&rsquo;re likely way over budget on mobile. Aim to complete all of your work within 10ms to have some margin. <strong>Note:</strong> This margin is for slower devices and you should almost certainly run this analysis on mobile using <a href="https://developers.google.com/chrome-developer-tools/docs/remote-debugging">remote debugging</a> (if building for mobile, which you should be!). &nbsp;<p><a href="image051.png"><img alt="" class="alignnone size-full wp-image-5105" height="173" src="images/image051.png" title="image05" width="489" /></a></p></li>
	<li>Once you&rsquo;ve noticed you have a janky frame, check what the cause of it was. Was it a huge paint? CSS layout issue? JavaScript</li>
	<li><strong>Fix the problem. If it was a paint or layout issue:</strong>
		<ol>
			<li>Go to Settings and enable "continuous page repainting".</li>
			<li>Walk through the DOM tree, hiding non-essential elements using the hide (H) shortcut. You might discover hiding particular element(s) make a large difference to your paint times and frame rate.</li>
			<li>We now know there is something about an element slowing painting down. Uncheck styles that could have an impact on paint time (e.g box-shadow) for the element and check your frame rate again.</li>
			<li>Continue until you&rsquo;ve located the style responsible for the slow-down.</li>
		</ol>
	</li>
	<li>Rinse and repeat</li>
</ol>
<p>Especially on sites that rely heavily on scroll, you might discover that your main content is relying on <code>overflow:scroll</code>. This is a real challenge as this scrolling isn&rsquo;t GPU accelerated in any way so the content is repainted whenever your user scrolls. You can work around such issues using normal page scroll (<code>overflow:visible</code>) and position:fixed.</p>

<h2>Timeline reference</h2>
<ul>
<li>Composite Layer - Chrome's rendering engine composited image layers.</li>
<li>Image Decode - An image resource was decoded.</li>
<li>Image Resize - An image was resized from its native dimensions.</li>
<li>Paint - Composited layers were painted to a region of the display. Hovering over a Paint record highlights the region of the display that was updated.</li>
<li>Invalidate layout - The page layout was invalidated by a DOM change.</li>
<li>Layout - A page layout was executed.</li>
<li>Recalculate style - Chrome recalculated element styles.</li>
<li>Scroll - The content of nested view was scrolled.</li>
</ul>

<h2>GPU acceleration</h2>

<p>The next thing we're going to look at is GPU acceleration. In the past, Web browsers have relied pretty heavily on the CPU to render pages. This involved two things: firstly, painting elements into a bunch of textures, called layers; and secondly, compositing all of those layers together to the final picture seen on screen.
Over the past few years, however, we've found that getting the GPU involved in the compositing process can lead to some significant speeding up. The premise is that, while the textures are still painted on the CPU, they can be uploaded to the GPU for compositing. Assuming that all we do on future frames is move elements around (using CSS transitions or animations) or change their opacity, we simply provide these changes to the GPU and it takes care of the rest. We essentially avoid having to give the GPU any new graphics; rather, we just ask it to move existing ones around. This is something that the GPU is exceptionally quick at doing, thus improving performance overall.</p>

<p>There is no guarantee that this hardware compositing will be available and enabled on a given platform, but if it is available the first time you use, say, a 3D transform on an element, then it will be enabled in Chrome. Many developers use the translateZ hack to do just that. The other side effect of using this hack is that the element in question will get its own layer, which may or may not be what you want. It can be very useful to effectively isolate an element so that it doesn't affect others as and when it gets repainted. It's worth remembering that the uploading of these textures from system memory to the video memory is not necessarily very quick. The more layers you have, the more textures need to be uploaded and the more layers that will need to be managed, so it's best not to overdo it.</p>

<p>Another great setting in Developer Tools that can help here is “Show composited layer borders.” This feature will give you insight into those DOM elements that are being manipulated at the GPU level.</p>

<p>If an element is taking advantage of the GPU acceleration, you'll see an orange border around it with this on. Now as we scroll through, we don't really see any use of composited layers on this page — not when we click “Scroll to top” or otherwise.
Chrome is getting better at automatically handling layer promotion in the background; but, as mentioned, developers sometimes use the translateZ hack to create a composited layer. Below is one site's homepage with translateZ(0) applied to all pins. It's not hitting 60 FPS, but it is getting closer to a consistent 30 FPS on desktop, which is actually not bad.</p>

<p><img src="images/Screen-Shot-2013-05-15-at-19.03.13.png"/></p>

<p>Remember to test on both desktop and mobile, though; their performance characteristics vary wildly. Use the timeline in both, and watch your paint time chart in Continuous Paint mode to evaluate how fast you're busting your budget.
Again, don't use this hack on every element on the page - it might pass muster on desktop, but it won't on mobile. The reason is that there is increased video memory usage and an increased layer management cost, both of which could have a negative impact on performance. Instead, use hardware compositing only to isolate elements where the paint cost is measurably high.</p>

<h2>Additional Tools</h2>
<h3>Show paint rectangles</h3>
<p>Under &lsquo;Rendering&rsquo; in the Settings cog, you can enable a feature called &lsquo;Show paint rectangles&rsquo; to help you visually see the area repainted in each frame. With this feature enabled, it can become easy to visualize what slows pages down. You want to keep the areas being repainted as small as possible.</p>
<p>&nbsp;</p>
<p><a href="image06.png"><img alt="" class="alignnone size-large wp-image-5107" height="397" src="images/image06-1024x678.png" /></a></p>
<h3>FPS counter</h3>
<p>An older, but equally as useful tool for visualizing frame rate and jank is the real-time FPS counter. This can be enabled in the DevTools by going to the Settings menu and checking Show FPS meter.</p>
<p style="text-align: center;"><a href="image04.png"><img alt="" class="alignnone size-full wp-image-5108" height="119" src="images/image04.png" title="image04" width="186" /></a></p>
<p>When activated, you will see a dark box in the top-right corner of your page with frame statistics. The counter can be used during live editing to diagnose what in your page is causing a drop-off in frame rate without having to switch back and forth with the Timeline view.</p>
<p><img alt="" class="alignnone size-large wp-image-5109" height="389" src="images/image01-1024x665.png" title="image01" width="600" /></p>
<p>Keep in mind that just tracking the FPS counter may lead to you not noticing frames with intermittent jank. Be careful when using the content. It is also worth noting that FPS on desktop does not equal FPS on devices and special care should be taken to profile the performance there too.</p>

<h2>Tutorial: Getting a jank-free mobile web experience</h2>

<p>We've talked the talk, but let's look at a simple app with some janky animation and see if we can optimize it to be jank-free. Now remember that the performance of your page on mobile differs greatly from what it does on desktop. Luckily browsers like Chrome and Opera expose tooling that can profile both your rendering performance on desktop as well as your performance on connected mobile devices. This is done via remote debugging, which you'll need to get setup before you can profile your pages on mobile.</p>

<img src="images/pre.png"/>

<h3>Setting Up Remote Debugging</h3>

<p>You'll normally remotely debug your pages over USB. As long as your mobile device is connected to your development machine, you'll be able to profile pages using the Timeline as well as view and edit HTML, scripts and styles under you have an optimized page which behaves a little better on all of your target devices.</p>

<p>To get remote debugging setup for your version of Chrome or Opera, follow the remote debugging guide over in the Chrome Developer Tools documentation. You'll then be able to work through tutorial below on either a real mobile device or your desktop.</p>

<p>Note that the docs above will also give you two choices for accessing pages you would like to debug on your device. You can either open up the page on your device's browser or if you would prefer, use a new feature called reverse-port forwarding to debug a locally hosted version of your code on your device.</p>

<h3>Let's get optimizing!</h3>

<p><div class="screenshot"><img width="722" alt="Debugging Chrome for Android using the Chrome Developer Tools" src="images/remote-debug-overview.png"/></div></p>

<p>Now that you hopefully have remote debugging setup:</p>

<p>1. Open up <a href="http://jsfiddle.net/AxEJY/">http://jsfiddle.net/AxEJY/</a>. </p>
<p>2. Click 'animate!'. As you can see there is a visual break in motion, resulting in a suboptimal animation. We can record a Timeline session during the animation of this page to confirm that we have an issue hitting an optimal frame rate. The animation performs far worse on mobile than it does on desktop because we're working with more limited GPU.</p>
<p>3. Let's see what's causing things to slow down. Here's the JavaScript for our animation as well as the CSS.

<p>JavaScript:</p>

<pre>
// setup
var rAF = window.requestAnimationFrame;
var startBtn = document.querySelector('.animate');
var stopBtn = document.querySelector('.stop');

// state
window.running = false;

// add listeners
// start
startBtn.addEventListener("click", function(e){
   running = true;
   rAF(update); 
});

// stop
stopBtn.addEventListener("click", function(e){
   running = false; 
});

// Set the heights for all these
// movers in simple CSS style.top
var movers = document.querySelectorAll('.mover');
(function init() {
    for (var m = 0; m < movers.length; m++) {
        movers[m].style.top = (m * 20 + 50) + 'px';
    }
})();

// animation loop
function update(timestamp) {
    for (var m = 0; m < movers.length; m++) {
            movers[m].style.left = ((Math.sin(movers[m].offsetTop + timestamp / 1000) + 1) * 500) + 'px';
        }

    if (window.running){
        rAF(update);
    }
};
rAF(update);
</pre>

<p>CSS:</p>
<pre>
.mover {
  background:url(http://jankfree.org/velocity-europe/examples/too-much-layout/particle.png);
  height:100px;
  width:100px;
  position:absolute;
  z-index:0;
}

input {
  z-index:2;
  font-size:25pt;
  height:100px;
  width:100px;
  display:inline-block;
}
</pre>


    <h2>Analyze the recording</h2>

    <p>
        Looking at the recording of the first few frames it's clear that each one is taking over 300ms to complete. If you hover your mouse over one of the frames a pop-up appears showing additional details about the frame.</p>

       <div class="screenshot"> <img src="images/frame-rate.png" alt=""></div>
    <p>
        Locate an Animation Frame Fired record and notice the yellow warning icon next to it, indicating a forced synchronous layout. The icon is slightly dimmed indicating that one of its child records contains the offending code, rather than this record itself. Expand the Animation Frame Fired to view its children.
    </p>

    <div class="screenshot"><img src="images/recording-1.png"></div>

    <p>
        The child records show a long, repeating pattern of <strong>Recalculate Style</strong> and <strong>Layout</strong> records. Each layout record is a result of the style recalculation that, in turn, is a result of the <code>requestAnimationFrame()</code> handler requesting the value of <code>offsetTop</code> for each image on the page. Hover your mouse over one of the Layout records and click the link for sources.js next to the Layout Forced property.
    
    <div class="screenshot"><img src="images/layout-warning-hover.png"></div>
    
    p>
        The Sources panel opens at line 43 of the source file at the <code>update()</code> function, which is the <code>requestAnimationCallback()</code> callback handler. The handler computes the image's <code>left</code> CSS style proeprty on the the image's <code>offsetTop</code> value. This forces Chrome to perform a new layout immediately to make sure it provides the correct value.
    </p>

    <pre class="prettyprint lang-js">
// Animation loop
function update(timestamp) {
    for(var m = 0; m < movers.length; m++) {
        movers[m].style.left = ((Math.sin(movers[m].offsetTop + timestamp/1000)+1) * 500) + 'px';
        }
    raf = window.requestAnimationFrame(update);
};
</pre>

<p>We know that forcing a page layout during every animation frame is slowing things down. Now we can try to fix the problem directly in DevTools.</p>

<h2>Apply fix within DevTools</h2>

    <p>Now that we have an idea what's causing the performance issues, we can modify the JavaScript file directly in the Sources panel and test our changes on desktop or our mobile device right away.</p>
    
    <ol>
        <li>In the Sources panel that was opened previously, replace line 43 with the following code.</li>
            <code style="prettyprint" lang-js><pre>movers[m].style.left = ((Math.sin(m + timestamp/1000)+1) * 500) + 'px';</pre></code>
            <p>This version computes each image's <code>left</code> style property on its index in its holding array instead of on a layout-dependent property (<code>offsetWidth</code>).</p>

        <li>Save your changes by pressing Cmd-S or Ctrl-S.</li>
    </ol>

<h2>Verify with another recording</h2>

        <p>The animation is clearly faster and smoother than before, but it's always good practice to measure the difference with another recording. It should look something like the recording below.</p>

        <div class="screenshot"><img src="images/fixed.png"></div>


<p>Try it out. The corrected code for this sample can be found at <a href="http://jsfiddle.net/k4yM3/">http://jsfiddle.net/k4yM3/</a> and now performs at close to 60fps.</p>

<p><img src="images/post.png"/></p>


<h2>Pro-tips:</h2>

<p>Your JavaScript can annotate DevTools Timeline recordings using <code>console.timeStamp()</code> which works regardless of whether you're using remote debugging or not. See below for 'Adding result', an annotation added by our code during profiling:</p>

<img src="images/timestamp.png" alt="">

<p>Your code can also use console.time() & console.timeEnd() to mark ranges in DevTools Timeline recordings:
</p>

<img src="images/protip3.jpg" alt="">


<p>If you enable "Show CPU activity on the ruler", you can overlay the CPU activity in your Timeline recordings. With this on, the light bars indicate the CPU was busy. If you hover over a CPU bar, this highlights the region during which the CPU was active.</p>

<img src="images/Screen Shot 2013-05-27 at 16.56.06.png" alt="">

<p>If you would like to drill down to records of a particular type, you can do this by using the Ctrl + F shortcut (Cmd + F on Mac) when in the Timeline. Just enter in the name of the record type (e.g 'scroll') and Timeline will only show the records containing the term.</p>

<img src="images/Screen Shot 2013-05-27 at 17.01.35.png" alt="">

<p>In case you're wondering what those transparent bars in the Timeline mean, these hollow frames correspond to one of two things: your JavaScript on the main thread was busy doing something we forgot to show (instrument) in the DevTools or you were bottlenecked by your GPU.</p>

<img src="images/trans.png" alt="">


<h2>Paint profiling tools in other browsers</h2>

<p>Firefox - paint flashing, IE11 - ? Webkit Nightlies - layout viewer.</p>

<p>The Firefox nightlies have a feature called paint flashing which can also be used to determine what regions of the page the browser is repainting. With paint flashing turned on, each region is tinted with a random color making it really easy to distinguish one region from another. Regions with really heavy paint flashing are the ones that are going to cost you, so try to minimize them as much as possible.</p>

<p>
    <ol>
    <li>Check to ensure you have Firefox 11 or higher installed (Beta, Aurora, or Nightly).</li>
    <li>Go to <strong>about:config</strong></li>
    <li>Accept the warning that is displayed</li>
    <li>Right-click and select <strong>New -&gt; Boolean</strong></li>
    <li>Type <strong>nglayout.debug.paint_flashing</strong></li>
    <li>Set the option to <strong>true</strong>. That's it!</li>
    </ol>
</p>



<h2>Conclusions</h2>

<p>Our mobile users want to be able to rapidly get information with as little delay as possible. In addition to making things look sexy, it's our responsibility to make sure that our pages are loading and rendering quickly, especially on mobile devices. If not, we risk our user engagement dropping and our user-experience suffering as well.</p>

<p>So, be sure to measure paint performance on both desktop and mobile. If all goes well, your users will end up with snappier, more silky-smooth experiences, regardless of the device they're using.To learn more about optimizing the paint performance of your pages, check out http://jankfree.org and the official Chrome DevTools <a href="https://developers.google.com/chrome-developer-tools/docs/using-timeline">documentation</a>.</p>

<p>Although at the time of writing, Chrome and Opera have the best tools to profile paint performance (Safari and Firefox are also making lots of progress here!), we strongly recommend testing and measuring your pages in other browsers to get a feel for what your own users might experience (where feasible). Performance can vary massively between them, and a performance smell in one browser might not be present in another.</p>

<p>Measure for yourself, understand the abstractions, know your browser's internals. In time, we hope that the cross- browser tooling for this area improves so that developers can get an accurate picture of rendering performance, regardless of the browser being used.</p>



